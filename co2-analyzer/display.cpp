#include "display.h"

#include <stdlib.h>
#include <avr/io.h>
#include <avr/pgmspace.h>


#define DISPLAY_BUFFER_SIZE			DISPLAY_X_RESOLUTION * DISPLAY_Y_RESOLUTION / 8
#define DISPLAY_CONVERTER_BUFFER	10

static const unsigned char CHARS_TABLE[][DISPLAY_SYMBOL_WIDTH] __attribute__((progmem)) = {
	// symbol,			index
	{ 0x7c, 0xa2, 0x92, 0x8a, 0x7c },	// 0				0
	{ 0x88, 0x84, 0xfe, 0x80, 0x80 },	// 1				1
	{ 0xc4, 0xa2, 0xa2, 0xa2, 0x9c },	// 2				2
	{ 0x42, 0x82, 0x8a, 0x8a, 0x76 },	// 3				3
	{ 0x1e, 0x10, 0x10, 0x10, 0xfe },	// 4				4
	{ 0x4e, 0x8a, 0x8a, 0x8a, 0x72 },	// 5				5
	{ 0x7c, 0x8a, 0x8a, 0x8a, 0x70 },	// 6				6
	{ 0x02, 0x02, 0xf2, 0x0a, 0x06 },	// 7				7
	{ 0x74, 0x8a, 0x8a, 0x8a, 0x74 },	// 8				8
	{ 0x0c, 0x92, 0x92, 0x92, 0x7c },	// 9				9
	{ 0x7c, 0x82, 0x82, 0x82, 0x44 },	// C				10
	{ 0x7c, 0x82, 0x82, 0x82, 0x7c },	// O				11
	{ 0xf8, 0x48, 0x48, 0x30, 0x00 },	// low p			12
	{ 0xf8, 0x08, 0x38, 0x08, 0xf0 },	// low m			13
	{ 0xe8, 0xa8, 0xa8, 0xb8, 0x00 },	// low 2			14
	{ 0x48, 0x00, 0x00, 0x00, 0x00 },	// colon			15
	{ 0xFE, 0x83, 0x83, 0x83, 0xFE },	// battery empty	16
	{ 0xFE, 0xC3, 0xC3, 0xC3, 0xFE },	// battery 1
	{ 0xFE, 0xE3, 0xE3, 0xE3, 0xFE },	// battery 2
	{ 0xFE, 0xF3, 0xF3, 0xF3, 0xFE },	// battery 3
	{ 0xFE, 0xFB, 0xFB, 0xFB, 0xFE },	// battery 4
	{ 0xFE, 0xFF, 0xFF, 0xFF, 0xFE },	// battery full
	{ 0x7C, 0x44, 0x44, 0x7C, 0x00 },	// 0				22
	{ 0x44, 0x7C, 0x40, 0x00, 0x00 },	// 1
	{ 0x74, 0x54, 0x54, 0x5C, 0x00 },	// 2
	{ 0x44, 0x44, 0x54, 0x7C, 0x00 },	// 3
	{ 0x1C, 0x10, 0x10, 0x7C, 0x00 },	// 4
	{ 0x5C, 0x54, 0x54, 0x74, 0x00 },	// 5
	{ 0x7C, 0x54, 0x54, 0x74, 0x00 },	// 6
	{ 0x04, 0x64, 0x14, 0x0C, 0x00 },	// 7
	{ 0x7C, 0x54, 0x54, 0x7C, 0x00 },	// 8
	{ 0x5C, 0x54, 0x54, 0x7C, 0x00 },	// 9
	{ 0x78, 0x24, 0x24, 0x78, 0x00 },	// a				32
	{ 0x7C, 0x54, 0x54, 0x28, 0x00 },	// b
	{ 0x38, 0x44, 0x44, 0x28, 0x00 },	// c
	{ 0x7C, 0x44, 0x44, 0x38, 0x00 },	// d
	{ 0x7C, 0x54, 0x54, 0x44, 0x00 },	// e
	{ 0x7C, 0x14, 0x14, 0x04, 0x00 },	// f
	{ 0x38, 0x44, 0x54, 0x30, 0x00 },	// g
	{ 0x7C, 0x10, 0x10, 0x7C, 0x00 },	// h
	{ 0x7C, 0x00, 0x00, 0x00, 0x00 },	// i
	{ 0x60, 0x40, 0x3C, 0x00, 0x00 },	// j
	{ 0x7C, 0x10, 0x10, 0x6C, 0x00 },	// k
	{ 0x7C, 0x40, 0x40, 0x40, 0x00 },	// l
	{ 0x7C, 0x04, 0x1C, 0x04, 0x78 },	// m
	{ 0x78, 0x04, 0x04, 0x78, 0x00 },	// n
	{ 0x38, 0x44, 0x44, 0x38, 0x00 },	// o
	{ 0x7E, 0x22, 0x22, 0x1C, 0x00 },	// p
	{ 0x38, 0x44, 0x64, 0x78, 0x00 },	// q
	{ 0x7C, 0x24, 0x24, 0x58, 0x00 },	// r
	{ 0x48, 0x54, 0x54, 0x24, 0x00 },	// s
	{ 0x04, 0x7C, 0x04, 0x00, 0x00 },	// t
	{ 0x7E, 0x56, 0x6A, 0x7E, 0x00 },	// unknown			52
};

void display_init()
{
	// GPIO Setup
	DDR_DISPLAY |= (1 << PIN_RESET) | (1 << PIN_DC);
	DDRB |= (1 << PIN_SCE) | (1 << PIN_SDIN) | (1 << PIN_SCLK);

	// SPI setup
	SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR0); // master mode,

	PORT_DISPLAY &=~ (1 << PIN_RESET);
	PORT_DISPLAY |= (1 << PIN_RESET);
	display_send(LCD_C, 0x21);  // LCD Extended Commands.
	display_send(LCD_C, 0xBA);  // Set LCD Vop (Contrast).
	//display_send(LCD_C, 0x04);  // Set Temp coefficent. //0x04
	//display_send(LCD_C, 0x14);  // LCD bias mode 1:48. //0x13
	display_send(LCD_C, 0x20);  // LCD Basic Commands
	display_send(LCD_C, 0x0C);  // LCD in normal mode.
}

void display_clear() {
	display_fill(0);
}

void display_fill(unsigned char code) {
	for (int i = 0; i < DISPLAY_BUFFER_SIZE; i++) {
		display_send(LCD_D, code);
	}
}

void display_print_number(int x) {
	char buffer[DISPLAY_CONVERTER_BUFFER];
	char * digit = itoa(x, buffer, 10);
	while (*digit) {
		display_send_char(*digit++ - '0');
	}
}

void display_send(unsigned char dc, unsigned char data)
{
	if (dc == LCD_D) {
		PORT_DISPLAY |= (1 << PIN_DC);
	} else {
		PORT_DISPLAY &= ~(1 << PIN_DC);
	}

	PORTB &= ~(1 << PIN_SCE);

	SPDR = data;
	while (!(SPSR & (1 << SPIF)));

	PORTB |= (1 << PIN_SCE);
}

void display_send_char(unsigned char code) {
	for (unsigned char i = 0; i < DISPLAY_SYMBOL_WIDTH; i++) {
		unsigned char data = pgm_read_byte(&(CHARS_TABLE[code][i]));
		if (data == 0) {
			break;
		}
		display_send(LCD_D, data);
	}
	display_send(LCD_D, 0);
}

void display_send_space() {
	display_send(LCD_D, 0);
	display_send(LCD_D, 0);
	display_send(LCD_D, 0);
}

void display_send_prg_string(const char * str) {
	unsigned char i = 0;
	while (unsigned char ch = pgm_read_byte(&(str[i]))) {
		if (ch == ' ') {
			display_send_space();
		} else if (ch >= '0' && ch <= '9') {
			display_send_char(SMALL_DIGITS + ch - '0');
		} else if (ch >= 'a' && ch <= 'z') {
			display_send_char(SMALL_CHARS + ch - 'a');
		} else {
			display_send_char(CHAR_UNKNOWN);
		}
		i++;
	}
}

void display_set_cursor(unsigned char x, unsigned char y) {
	display_send(LCD_C, 0x40 + (y % 6));
	display_send(LCD_C, 0x80 + (x % 12) * 7);
}

unsigned char display_get_table_byte(unsigned char code, unsigned char index) {
	return pgm_read_byte(&(CHARS_TABLE[code][index]));
}
